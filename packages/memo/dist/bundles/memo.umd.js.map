{"version":3,"file":"memo.umd.js","sources":["../../../../node_modules/tslib/tslib.es6.js","../../src/cacheable/cacheable.aspect.ts","../../src/errors.ts","../../src/memo.types.ts","../../src/drivers/memo-frame.ts","../../src/drivers/scheduler.ts","../../src/drivers/indexed-db/idb-memo.driver.ts","../../src/utils/hash.ts","../../src/utils/instant-promise.ts","../../../../node_modules/flatted/esm/index.js","../../src/drivers/localstorage/serializers/ls-serializer.ts","../../src/drivers/localstorage/localstorage.driver.ts","../../src/utils/lz-string.ts","../../src/drivers/localstorage/serializers/lz-memo.serializer.ts","../../../../node_modules/fast-copy/src/utils.ts","../../../../node_modules/fast-copy/src/index.ts","../../src/marshalling/marshallers/object-marshaller.ts","../../src/marshalling/marshallers/cacheable-marshaller.ts","../../src/marshalling/marshallers/array-marshaller.ts","../../src/marshalling/marshallers/basic-marshaller.ts","../../src/marshalling/marshallers/date-marshaller.ts","../../src/marshalling/marshallers/noop-marshaller.ts","../../src/marshalling/marshallers/promise-marshaller.ts","../../src/marshalling/marshallers-registry.ts","../../src/memo.aspect.ts","../../src/profiles/default.profile.ts","../../src/memo.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","import { Aspect, Compile } from '@aspectjs/core/annotations';\nimport { AdviceType, CompileContext, on } from '@aspectjs/core/commons';\nimport { assert, getOrComputeMetadata, isObject } from '@aspectjs/core/utils';\nimport { Cacheable, CacheableOptions } from './cacheable.annotation';\n\n/**\n * @public\n */\nexport type Prototype = {\n    constructor: Function;\n};\n\n/**\n * Store the signature of an object annotated wuth @Cacheable in order\n * to be able to cache it with the @Memo annotation\n *\n * @public\n */\nexport interface CacheableAspect {\n    readonly cacheTypeStore: CacheTypeStore;\n}\n\n/**\n * @public\n */\nexport interface CacheTypeStore {\n    getPrototype(key: string): Prototype;\n    getVersion(key: string): any;\n    getTypeKey<T extends Prototype>(proto: T): string;\n\n    addPrototype<T extends Prototype>(proto: T, key: string, version?: any): void;\n}\n\n/**\n * Assign a key to the prototype of a class into a CacheTypeStore,\n * so that Memo drivers can inflate memoized objects with proper types.\n *\n * @public\n */\n@Aspect('@aspectjs/cacheable')\nexport class DefaultCacheableAspect implements CacheableAspect {\n    constructor(public readonly cacheTypeStore: CacheTypeStore = new _CacheTypeStoreImpl()) {}\n    @Compile(on.class.withAnnotations(Cacheable))\n    registerCacheKey(ctxt: CompileContext<any, AdviceType.CLASS>) {\n        let options = ctxt.annotations.onSelf(Cacheable)[0].args[0] as CacheableOptions;\n        if (!isObject(options)) {\n            options = {\n                typeId: options,\n            };\n        }\n        const typeId = options.typeId ?? _generateTypeId(ctxt.target.proto);\n\n        this.cacheTypeStore.addPrototype(ctxt.target.proto, typeId, options.version);\n    }\n}\n\n/**\n * Store class prototypes along with a defined key.\n * @internal\n */\nexport class _CacheTypeStoreImpl implements CacheTypeStore {\n    private readonly _prototypes: Map<string, { version?: string; proto: Prototype }> = new Map();\n\n    getPrototype(key: string): Prototype {\n        assert(!!key, 'key must be defined');\n        const entry = this._prototypes.get(key);\n        if (!entry) {\n            throw new Error(`no prototype found for key ${key}`);\n        }\n        return entry.proto;\n    }\n\n    getTypeKey<T extends Prototype>(prototype: T): string {\n        return Reflect.getOwnMetadata('@aspectjs/cacheable:typekey', prototype);\n    }\n\n    addPrototype(proto: Prototype, typeId: string, version?: string): void {\n        const existingProto = this._prototypes.get(typeId);\n        if (existingProto && existingProto !== proto) {\n            throw new Error(\n                `Cannot call @Cacheable({typeId = ${typeId}}) on ${proto?.constructor?.name}: typeId is already assigned to ${existingProto?.constructor?.name}`,\n            );\n        }\n\n        this._prototypes.set(typeId, { proto, version });\n    }\n\n    getVersion(key: string): string {\n        return this._prototypes.get(key)?.version ?? undefined;\n    }\n}\n\nlet globalId = 0;\nfunction _generateTypeId(proto: any): string {\n    return getOrComputeMetadata('@aspectjs/cacheable:typekey', proto, () => {\n        return `${proto.constructor.name}#${globalId++}`;\n    });\n}\n","import { UnmarshallingContext } from './marshalling/marshalling-context';\n\nexport class MemoAspectError extends Error {\n    constructor(public readonly message: string) {\n        super(message);\n    }\n}\n\nexport class VersionConflictError extends MemoAspectError {\n    constructor(public readonly message: string, public readonly context: UnmarshallingContext) {\n        super(message);\n    }\n}\n","import { MemoFrame } from './drivers';\nimport { MemoAspectError } from './errors';\n\nconst KEY_IDENTIFIER = '@aspectjs:Memo';\n\n/**\n * @public\n */\nexport class MemoKey {\n    public readonly namespace: string;\n    public readonly targetKey: string;\n    public readonly instanceId: string;\n    public readonly argsKey: string;\n    private readonly _strValue: string;\n\n    constructor(key: Omit<MemoKey, '_strValue'>, namespace?: string) {\n        this.namespace = namespace ?? key.namespace;\n        this.targetKey = key.targetKey;\n        this.instanceId = key.instanceId;\n        this.argsKey = key.argsKey;\n        this._strValue = `${KEY_IDENTIFIER}:ns=${this.namespace}&tk=${this.targetKey}&id=${this.instanceId}&ak=${this.argsKey}`;\n    }\n\n    static parse(str: string, throwIfInvalid = true): MemoKey | null {\n        if (!str.startsWith(KEY_IDENTIFIER)) {\n            throw new TypeError(`Key ${str} is not a memo key`);\n        }\n        const rx = new RegExp(\n            `${KEY_IDENTIFIER}:ns=(?<namespace>.*?)&tk=(?<targetKey>.*?)&id=(?<instanceId>.*?)&ak=(?<argsKey>.*)`,\n        );\n        const r = rx.exec(str);\n        if (!r) {\n            if (throwIfInvalid) {\n                throw new MemoAspectError(`given expression is not a MemoKey: ${str}`);\n            }\n            return null;\n        }\n        return new MemoKey(r.groups as any);\n    }\n\n    toString(): string {\n        return this._strValue;\n    }\n}\n\n/**\n * @public\n */\nexport interface MemoEntry<T = any> {\n    readonly key: MemoKey;\n    readonly frame: MemoFrame<T>;\n    readonly signature?: string;\n    readonly expiration?: Date;\n}\n","import { isPromise } from '@aspectjs/core/utils';\n\n/**\n * Flat dehydrated representation of an object that can be stored easily\n * @public\n */\nexport interface MemoTypeInfoFrame {\n    type?: string;\n    instanceType?: string;\n    expiration?: Date;\n    version?: string;\n}\n\n/**\n * A MemoEntry once marshalled\n * @public\n */\nexport class MemoFrame<T = unknown> implements MemoTypeInfoFrame {\n    type?: string;\n    instanceType?: string;\n    version?: string;\n    value: T;\n    hash?: string;\n    async: Promise<T>;\n    private _resolved: boolean;\n    constructor(frame: Partial<MemoFrame<T>>) {\n        Object.assign(this, frame);\n    }\n\n    setValue<X>(value: X): MemoFrame<X> {\n        this._resolved = true;\n        this.async = null;\n        const frame = (this as any) as MemoFrame<X>;\n        frame.value = value;\n        return frame;\n    }\n\n    setAsyncValue<X>(value: Promise<X>): MemoFrame<X> {\n        const frame = (this as any) as MemoFrame<X>;\n        this._resolved = false;\n        this.async = value.then((v) => {\n            frame.value = v;\n            this._resolved = true;\n            return (frame.value as any) as T;\n        });\n        return frame;\n    }\n\n    isAsync() {\n        return isPromise(this.async);\n    }\n}\n","/**\n * In case a @Memo method returns a promise, the corresponding MemoValue\n * can be persisted only once the promise gets resolved. As a result, all subsequent operations should be deferred.\n * This stores all the pending operations for a given key in call order,\n * to ensure an operation does not occurs before the previous operations.\n */\nlet globalOperationId = 0;\nexport class Scheduler {\n    private readonly _pendingOps: Record<string, PromiseLike<any>> = {};\n    private readonly _lastOperationId: Record<string, number> = {};\n\n    /** Add the given promise to the promise queue for this key **/\n    add<T>(key: string, op: () => PromiseLike<T>): T extends Promise<any> ? T : PromiseLike<T> {\n        const k = key.toString();\n        if (this._pendingOps[k]) {\n            const opId = globalOperationId++;\n            this._lastOperationId[k] = opId;\n\n            this._pendingOps[k] = this._pendingOps[k]\n                .then(() => op())\n                .then((r) => {\n                    if (this._lastOperationId[k] === opId) {\n                        delete this._pendingOps[k];\n                        delete this._lastOperationId[k];\n                    }\n\n                    return r;\n                });\n        } else {\n            this._pendingOps[k] = op();\n        }\n\n        return this._pendingOps[k] as any;\n    }\n}\n","import { WEAVER_CONTEXT } from '@aspectjs/core';\nimport { MemoDriver } from '../memo.driver';\nimport { MemoEntry, MemoKey } from '../../memo.types';\nimport { assert } from '@aspectjs/core/utils';\nimport { MemoFrame, MemoTypeInfoFrame } from '../memo-frame';\nimport { LsMemoDriver } from '..';\nimport { MemoAspect } from '../../memo.aspect';\nimport { MemoAspectError } from '../../errors';\nimport { Scheduler } from '../scheduler';\nimport { MarshallingContext } from '../../marshalling/marshalling-context';\n\nenum TransactionMode {\n    READONLY = 'readonly',\n    READ_WRITE = 'readwrite',\n}\n\n/**\n * Options supported by the IdbMemoDriver\n * @public\n */\nexport interface IndexedDbDriverOptions {\n    indexedDB: typeof indexedDB;\n    localStorageDriver: LsMemoDriver;\n}\n\n/**\n * Memo driver to store async @Memo result into the Indexed Database.\n * @public\n */\nexport class IdbMemoDriver extends MemoDriver {\n    static readonly NAME = 'indexedDb';\n    readonly NAME = IdbMemoDriver.NAME;\n\n    static readonly DATABASE_NAME = 'IndexedDbMemoAspect_db';\n    static readonly STORE_NAME = 'results';\n    static readonly DATABASE_VERSION = 1; // change this value whenever a backward-incompatible change is made to the store\n    private readonly _scheduler = new Scheduler();\n    private _init$: Promise<IDBDatabase>;\n    private _localStorageDriver: MemoDriver;\n\n    constructor(protected _params: Partial<IndexedDbDriverOptions> = {}) {\n        super();\n        this._init$ = this._openDb();\n    }\n\n    private get _idb(): IDBFactory {\n        return this._params.indexedDB ?? indexedDB;\n    }\n\n    private get _ls(): MemoDriver {\n        this._localStorageDriver = this._findLsDriver();\n        return this._localStorageDriver;\n    }\n\n    getKeys(namespace: string): Promise<MemoKey[]> {\n        return this._runTransactional((store) => store.getAllKeys(), TransactionMode.READONLY).then((result) => {\n            return result\n                .map((id) => id.toString())\n                .map((str) => MemoKey.parse(str, false))\n                .filter((k) => !!k);\n        });\n    }\n\n    private _openDb() {\n        return new Promise<IDBDatabase>((resolve, reject) => {\n            const dbRequest = this._idb.open(IdbMemoDriver.DATABASE_NAME, IdbMemoDriver.DATABASE_VERSION);\n            dbRequest.addEventListener('upgradeneeded', () => {\n                const db = dbRequest.result;\n                const store = db.createObjectStore(IdbMemoDriver.STORE_NAME, {\n                    keyPath: 'ref', // TODO handle other MemoKey fields\n                    autoIncrement: false,\n                });\n                store.createIndex('by_key', 'key', { unique: true });\n            });\n            dbRequest.addEventListener('success', () => resolve(dbRequest.result));\n            dbRequest.addEventListener('error', (err) => reject(err));\n        });\n    }\n\n    getPriority(context: MarshallingContext): number {\n        return 100;\n    }\n\n    accepts(context: MarshallingContext): boolean {\n        return context.frame.isAsync();\n    }\n\n    read<T>(key: MemoKey): MemoEntry<T> {\n        const metaKey = createMetaKey(key);\n        const metaEntry = this._ls.read(metaKey);\n\n        if (!metaEntry) {\n            return null;\n        }\n\n        assert(!!metaEntry.frame?.type);\n        assert(!!metaEntry.key);\n\n        const asyncValue = this._runTransactional((tx) => tx.get(key.toString())).then((frame) => {\n            if (!frame) {\n                this._ls.remove(metaKey);\n                throw new MemoAspectError(`No data found for key ${key}`);\n            }\n            return frame.value;\n        });\n\n        const frame = new MemoFrame<T>({\n            ...metaEntry,\n            ...metaEntry.frame,\n        }).setAsyncValue(asyncValue);\n\n        this._scheduler.add(key.toString(), () => frame.async);\n\n        return frame\n            ? {\n                  ...metaEntry,\n                  key,\n                  frame,\n              }\n            : undefined;\n    }\n\n    remove(key: MemoKey): PromiseLike<void> {\n        return this._scheduler\n            .add(key.toString(), () => this._deleteIdbEntry(key).then(() => this._deleteLsEntry(key)))\n            .then(() => {});\n    }\n\n    write(entry: MemoEntry): PromiseLike<any> {\n        return this._scheduler.add(entry.key.toString(), () => {\n            const { value, ...metaFrame } = entry.frame;\n\n            const metaEntry: MemoEntry<MemoTypeInfoFrame> = {\n                ...entry,\n                key: createMetaKey(entry.key),\n                frame: metaFrame as MemoFrame,\n            };\n            // store only the Memo without its value\n            this._ls.write(metaEntry);\n\n            const valueFrame = { ref: entry.key.toString(), value };\n            return this._runTransactional((s) => s.put(valueFrame));\n        });\n    }\n\n    private _deleteIdbEntry(key: MemoKey) {\n        return this._runTransactional((s) => s.delete(key.toString()));\n    }\n\n    private _deleteLsEntry(key: MemoKey) {\n        this._ls.remove(key);\n    }\n\n    private _runTransactional<R>(\n        transactionFn: (store: IDBObjectStore) => IDBRequest<R>,\n        mode: TransactionMode = TransactionMode.READ_WRITE,\n    ): Promise<R> {\n        return this._init$.then(\n            (database) =>\n                new Promise<R>((resolve, reject) => {\n                    const store = database\n                        .transaction(IdbMemoDriver.STORE_NAME, mode)\n                        .objectStore(IdbMemoDriver.STORE_NAME);\n\n                    const request = transactionFn(store);\n\n                    request.addEventListener('success', () => resolve(request.result));\n                    request.addEventListener('error', (r) => {\n                        const error = (r.target as any)?.error ?? r;\n                        console.error(error);\n                        return reject(error);\n                    });\n                }),\n        );\n    }\n\n    private _findLsDriver() {\n        if (this._localStorageDriver) {\n            return this._localStorageDriver;\n        }\n\n        if (this._params.localStorageDriver) {\n            return this._params.localStorageDriver;\n        }\n\n        const drivers = (WEAVER_CONTEXT.getWeaver().getAspect('@aspectjs/memo') as MemoAspect).getDrivers();\n        if (!drivers['localStorage']) {\n            throw new MemoAspectError(\n                `${IdbMemoDriver.prototype.constructor.name} requires a \"localStorage\" driver, but option \"localStorageDriver\" is not set and no driver could be found with name \"localStorage\"`,\n            );\n        }\n        return drivers['localStorage'];\n    }\n}\n\nfunction createMetaKey(key: MemoKey) {\n    return new MemoKey(key, `${key.namespace}[idb_meta]`);\n}\n","/**\n *\n * @param str - the value to hash\n * @public\n */\nexport function hash(str?: string) {\n    return str\n        .split('')\n        .map((v) => v.charCodeAt(0))\n        .reduce((a, v) => (a + ((a << 7) + (a << 3))) ^ v)\n        .toString(16);\n}\n","/**\n * Like Promise.resolve, but call resolve synchronously as soon as '.then' gets called\n */\nimport { isPromise } from '@aspectjs/core/utils';\n\nexport class InstantPromise<T> implements PromiseLike<T> {\n    private _resolved: boolean;\n    private _value?: T;\n    private _rejectValue?: any;\n    private _onfulfilled: ((r: any) => InstantPromise<unknown>)[] = [];\n    private _onrejected: ((r: any) => InstantPromise<unknown>)[] = [];\n\n    constructor() {}\n\n    static resolve<T>(value?: T) {\n        return new InstantPromise<T>().resolve(value);\n    }\n\n    static all(...promises: PromiseLike<any>[]): PromiseLike<any[]> {\n        const results: any[] = [];\n\n        let promise: PromiseLike<any[]> = new InstantPromise<any[]>().resolve(results);\n        promises.forEach((p, i) => {\n            promise = promise.then(() => p).then((v) => (results[i] = v));\n        });\n\n        return promise;\n    }\n\n    then<TResult1 = T, TResult2 = never>(\n        onfulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,\n        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n    ): PromiseLike<TResult1 | TResult2> {\n        if (this._resolved) {\n            const res = onfulfilled(this._value);\n            if (isPromise(res)) {\n                return res;\n            } else {\n                return new InstantPromise<any>().resolve(res);\n            }\n        } else {\n            const delegate = new InstantPromise<TResult1>();\n            this._onfulfilled.push((r: any) => delegate.resolve(onfulfilled ? (onfulfilled(r) as any) : undefined));\n            this._onrejected.push((r: any) => delegate.resolve(onrejected ? (onrejected(r) as any) : undefined));\n            return delegate;\n        }\n    }\n\n    resolve(value: T): this {\n        if (this._resolved) {\n            throw new Error('promise already resolved');\n        }\n        this._resolved = true;\n        this._value = value;\n        if (this._onfulfilled) {\n            this._onfulfilled.forEach((f) => f(value));\n        }\n\n        return this;\n    }\n\n    reject(rejectValue: any): this {\n        if (this._resolved) {\n            throw new Error('promise already resolved');\n        }\n        this._resolved = true;\n        this._rejectValue = rejectValue;\n        if (this._onrejected) {\n            this._onrejected.forEach((f) => f(rejectValue));\n        }\n\n        return this;\n    }\n}\n","/*! (c) 2020 Andrea Giammarchi */\n\nconst {parse: $parse, stringify: $stringify} = JSON;\nconst {keys} = Object;\n\nconst Primitive = String;   // it could be Number\nconst primitive = 'string'; // it could be 'number'\n\nconst ignore = {};\nconst object = 'object';\n\nconst noop = (_, value) => value;\n\nconst primitives = value => (\n  value instanceof Primitive ? Primitive(value) : value\n);\n\nconst Primitives = (_, value) => (\n  typeof value === primitive ? new Primitive(value) : value\n);\n\nconst revive = (input, parsed, output, $) => {\n  const lazy = [];\n  for (let ke = keys(output), {length} = ke, y = 0; y < length; y++) {\n    const k = ke[y];\n    const value = output[k];\n    if (value instanceof Primitive) {\n      const tmp = input[value];\n      if (typeof tmp === object && !parsed.has(tmp)) {\n        parsed.add(tmp);\n        output[k] = ignore;\n        lazy.push({k, a: [input, parsed, tmp, $]});\n      }\n      else\n        output[k] = $.call(output, k, tmp);\n    }\n    else if (output[k] !== ignore)\n      output[k] = $.call(output, k, value);\n  }\n  for (let {length} = lazy, i = 0; i < length; i++) {\n    const {k, a} = lazy[i];\n    output[k] = $.call(output, k, revive.apply(null, a));\n  }\n  return output;\n};\n\nconst set = (known, input, value) => {\n  const index = Primitive(input.push(value) - 1);\n  known.set(value, index);\n  return index;\n};\n\nexport const parse = (text, reviver) => {\n  const input = $parse(text, Primitives).map(primitives);\n  const value = input[0];\n  const $ = reviver || noop;\n  const tmp = typeof value === object && value ?\n              revive(input, new Set, value, $) :\n              value;\n  return $.call({'': tmp}, '', tmp);\n};\n\nexport const stringify = (value, replacer, space) => {\n  const $ = replacer && typeof replacer === object ?\n            (k, v) => (k === '' || -1 < replacer.indexOf(k) ? v : void 0) :\n            (replacer || noop);\n  const known = new Map;\n  const input = [];\n  const output = [];\n  let i = +set(known, input, $.call({'': value}, '', value));\n  let firstRun = !i;\n  while (i < input.length) {\n    firstRun = true;\n    output[i] = $stringify(input[i++], replace, space);\n  }\n  return '[' + output.join(',') + ']';\n  function replace(key, value) {\n    if (firstRun) {\n      firstRun = !firstRun;\n      return value;\n    }\n    const after = $.call(this, key, value);\n    switch (typeof after) {\n      case object:\n        if (after === null) return after;\n      case primitive:\n        return known.get(after) || set(known, input, after);\n    }\n    return after;\n  }\n};\n\nexport const toJSON = any => $parse(stringify(any));\nexport const fromJSON = any => parse($stringify(any));\n","import { isUndefined } from '@aspectjs/core/utils';\nimport { parse, stringify } from 'flatted';\nimport { MemoEntry } from '../../../memo.types';\nimport { MemoFrame } from '../../memo-frame';\nimport { LsMemoSerializer } from './ls-serializer.type';\n\nenum RawMemoField {\n    VALUE,\n    TYPE,\n    INSTANCE_TYPE,\n    EXPIRATION,\n    VERSION,\n    SIGNATURE,\n    HASH,\n}\n\nconst F = RawMemoField;\n\nexport class SimpleLsSerializer implements LsMemoSerializer {\n    deserialize(serialized: string): Omit<MemoEntry, 'key'> {\n        if (!serialized) {\n            return null;\n        }\n        const raw = parse(serialized);\n        return {\n            expiration: raw[F.EXPIRATION] ? new Date(raw[F.EXPIRATION]) : undefined,\n            frame: new MemoFrame({\n                value: raw[F.VALUE],\n                type: raw[F.TYPE],\n                instanceType: raw[F.INSTANCE_TYPE],\n                version: raw[F.VERSION],\n                hash: raw[F.HASH],\n            }),\n            signature: raw[F.SIGNATURE],\n        };\n    }\n\n    serialize(entry: Omit<MemoEntry, 'key'>): string {\n        const raw = {} as any;\n\n        if (!isUndefined(entry.frame.value)) {\n            raw[F.VALUE] = entry.frame.value;\n        }\n        if (!isUndefined(entry.frame.type)) {\n            raw[F.TYPE] = entry.frame.type;\n        }\n        if (!isUndefined(entry.frame.instanceType)) {\n            raw[F.INSTANCE_TYPE] = entry.frame.instanceType;\n        }\n        if (!isUndefined(entry.frame.version)) {\n            raw[F.VERSION] = entry.frame.version;\n        }\n        if (!isUndefined(entry.frame.hash)) {\n            raw[F.HASH] = entry.frame.hash;\n        }\n        if (!isUndefined(entry.expiration)) {\n            raw[F.EXPIRATION] = entry.expiration;\n        }\n        if (!isUndefined(entry.signature)) {\n            raw[F.SIGNATURE] = entry.signature;\n        }\n        return stringify(raw);\n    }\n}\n","import { MarshallingContext } from '../../marshalling/marshalling-context';\nimport { MemoEntry, MemoKey } from '../../memo.types';\nimport { InstantPromise } from '../../utils';\nimport { MemoDriver } from '../memo.driver';\nimport { SimpleLsSerializer } from './serializers/ls-serializer';\nimport { LsMemoSerializer } from './serializers/ls-serializer.type';\n\n/**\n * Options supported by the LsMemoDriver\n * @public\n */\nexport interface LsMemoDriverOptions {\n    localStorage?: typeof localStorage;\n    serializer?: LsMemoSerializer;\n}\n\n/**\n * @public\n */\nexport const DEFAULT_LS_DRIVER_OPTIONS = {\n    serializer: new SimpleLsSerializer(),\n};\n\n/**\n * Memo driver to store async @Memo result into the Indexed Database.\n * @public\n */\nexport class LsMemoDriver extends MemoDriver {\n    static readonly NAME = 'localStorage';\n    readonly NAME = LsMemoDriver.NAME;\n\n    constructor(public options?: LsMemoDriverOptions) {\n        super();\n        this.options = { ...DEFAULT_LS_DRIVER_OPTIONS, ...options };\n        if (!this._ls) {\n            throw new Error('localStorage not available on this platform, and no implementation was provided');\n        }\n    }\n\n    private get _ls(): typeof localStorage {\n        return this.options.localStorage ?? localStorage;\n    }\n\n    getKeys(namespace: string): Promise<MemoKey[]> {\n        const res: MemoKey[] = [];\n        for (let i = 0; i < this._ls.length; ++i) {\n            const kStr = this._ls.key(i);\n            const key = MemoKey.parse(kStr, false);\n            if (key?.namespace === namespace) {\n                res.push(key);\n            }\n        }\n\n        return Promise.resolve(res);\n    }\n\n    /**\n     * Accepts all kind of results\n     * @param context - the marshalling context for the current 'to-be-stored' value\n     */\n    getPriority(context: MarshallingContext): number {\n        return 10;\n    }\n\n    read<T>(key: MemoKey): MemoEntry<T> {\n        const serializer = this.options?.serializer ?? DEFAULT_LS_DRIVER_OPTIONS.serializer;\n        const frame = serializer.deserialize(this._ls.getItem(key.toString())) as MemoEntry<T>;\n        return frame\n            ? {\n                  key,\n                  ...frame,\n              }\n            : undefined;\n    }\n\n    write(entry: MemoEntry): PromiseLike<void> {\n        const serializer = this.options?.serializer ?? DEFAULT_LS_DRIVER_OPTIONS.serializer;\n        this._ls.setItem(entry.key.toString(), serializer.serialize(entry));\n        return InstantPromise.resolve();\n    }\n\n    remove(key: MemoKey): PromiseLike<void> {\n        this._ls.removeItem(key.toString());\n        return InstantPromise.resolve();\n    }\n}\n","/*!\nMIT License\nCopyright (c) 2013 pieroxy\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\nconst f = String.fromCharCode;\n\nexport function compressToUTF16(input: string) {\n    if (input == null) return '';\n    return (\n        _compress(input, 15, function (a) {\n            return f(a + 32);\n        }) + ' '\n    );\n}\n\nexport function decompressFromUTF16(compressed: string) {\n    if (compressed == null) return '';\n    if (compressed == '') return null;\n    return _decompress(compressed.length, 16384, function (index: number) {\n        return compressed.charCodeAt(index) - 32;\n    });\n}\n\nfunction _compress(uncompressed: string, bitsPerChar: number, getCharFromInt: (c: number) => string) {\n    if (uncompressed == null) return '';\n    const context_dictionary: Record<string, number> = {};\n    const context_dictionaryToCreate: Record<string, boolean> = {};\n    const context_data = [];\n\n    let i,\n        value,\n        context_c = '',\n        context_wc = '',\n        context_w = '',\n        context_enlargeIn = 2, // Compensate for the first entry which should not count\n        context_dictSize = 3,\n        context_numBits = 2,\n        context_data_val = 0,\n        context_data_position = 0;\n\n    for (let ii = 0; ii < uncompressed.length; ii += 1) {\n        context_c = uncompressed.charAt(ii);\n        if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {\n            context_dictionary[context_c] = context_dictSize++;\n            context_dictionaryToCreate[context_c] = true;\n        }\n\n        context_wc = context_w + context_c;\n        if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {\n            context_w = context_wc;\n        } else {\n            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {\n                if (context_w.charCodeAt(0) < 256) {\n                    for (i = 0; i < context_numBits; i++) {\n                        context_data_val = context_data_val << 1;\n                        if (context_data_position == bitsPerChar - 1) {\n                            context_data_position = 0;\n                            context_data.push(getCharFromInt(context_data_val));\n                            context_data_val = 0;\n                        } else {\n                            context_data_position++;\n                        }\n                    }\n                    value = context_w.charCodeAt(0);\n                    for (i = 0; i < 8; i++) {\n                        context_data_val = (context_data_val << 1) | (value & 1);\n                        if (context_data_position == bitsPerChar - 1) {\n                            context_data_position = 0;\n                            context_data.push(getCharFromInt(context_data_val));\n                            context_data_val = 0;\n                        } else {\n                            context_data_position++;\n                        }\n                        value = value >> 1;\n                    }\n                } else {\n                    value = 1;\n                    for (i = 0; i < context_numBits; i++) {\n                        context_data_val = (context_data_val << 1) | value;\n                        if (context_data_position == bitsPerChar - 1) {\n                            context_data_position = 0;\n                            context_data.push(getCharFromInt(context_data_val));\n                            context_data_val = 0;\n                        } else {\n                            context_data_position++;\n                        }\n                        value = 0;\n                    }\n                    value = context_w.charCodeAt(0);\n                    for (i = 0; i < 16; i++) {\n                        context_data_val = (context_data_val << 1) | (value & 1);\n                        if (context_data_position == bitsPerChar - 1) {\n                            context_data_position = 0;\n                            context_data.push(getCharFromInt(context_data_val));\n                            context_data_val = 0;\n                        } else {\n                            context_data_position++;\n                        }\n                        value = value >> 1;\n                    }\n                }\n                context_enlargeIn--;\n                if (context_enlargeIn == 0) {\n                    context_enlargeIn = Math.pow(2, context_numBits);\n                    context_numBits++;\n                }\n                delete context_dictionaryToCreate[context_w];\n            } else {\n                value = context_dictionary[context_w];\n                for (i = 0; i < context_numBits; i++) {\n                    context_data_val = (context_data_val << 1) | (value & 1);\n                    if (context_data_position == bitsPerChar - 1) {\n                        context_data_position = 0;\n                        context_data.push(getCharFromInt(context_data_val));\n                        context_data_val = 0;\n                    } else {\n                        context_data_position++;\n                    }\n                    value = value >> 1;\n                }\n            }\n            context_enlargeIn--;\n            if (context_enlargeIn == 0) {\n                context_enlargeIn = Math.pow(2, context_numBits);\n                context_numBits++;\n            }\n            // Add wc to the dictionary.\n            context_dictionary[context_wc] = context_dictSize++;\n            context_w = String(context_c);\n        }\n    }\n\n    // Output the code for w.\n    if (context_w !== '') {\n        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {\n            if (context_w.charCodeAt(0) < 256) {\n                for (i = 0; i < context_numBits; i++) {\n                    context_data_val = context_data_val << 1;\n                    if (context_data_position == bitsPerChar - 1) {\n                        context_data_position = 0;\n                        context_data.push(getCharFromInt(context_data_val));\n                        context_data_val = 0;\n                    } else {\n                        context_data_position++;\n                    }\n                }\n                value = context_w.charCodeAt(0);\n                for (i = 0; i < 8; i++) {\n                    context_data_val = (context_data_val << 1) | (value & 1);\n                    if (context_data_position == bitsPerChar - 1) {\n                        context_data_position = 0;\n                        context_data.push(getCharFromInt(context_data_val));\n                        context_data_val = 0;\n                    } else {\n                        context_data_position++;\n                    }\n                    value = value >> 1;\n                }\n            } else {\n                value = 1;\n                for (i = 0; i < context_numBits; i++) {\n                    context_data_val = (context_data_val << 1) | value;\n                    if (context_data_position == bitsPerChar - 1) {\n                        context_data_position = 0;\n                        context_data.push(getCharFromInt(context_data_val));\n                        context_data_val = 0;\n                    } else {\n                        context_data_position++;\n                    }\n                    value = 0;\n                }\n                value = context_w.charCodeAt(0);\n                for (i = 0; i < 16; i++) {\n                    context_data_val = (context_data_val << 1) | (value & 1);\n                    if (context_data_position == bitsPerChar - 1) {\n                        context_data_position = 0;\n                        context_data.push(getCharFromInt(context_data_val));\n                        context_data_val = 0;\n                    } else {\n                        context_data_position++;\n                    }\n                    value = value >> 1;\n                }\n            }\n            context_enlargeIn--;\n            if (context_enlargeIn == 0) {\n                context_enlargeIn = Math.pow(2, context_numBits);\n                context_numBits++;\n            }\n            delete context_dictionaryToCreate[context_w];\n        } else {\n            value = context_dictionary[context_w];\n            for (i = 0; i < context_numBits; i++) {\n                context_data_val = (context_data_val << 1) | (value & 1);\n                if (context_data_position == bitsPerChar - 1) {\n                    context_data_position = 0;\n                    context_data.push(getCharFromInt(context_data_val));\n                    context_data_val = 0;\n                } else {\n                    context_data_position++;\n                }\n                value = value >> 1;\n            }\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n            context_enlargeIn = Math.pow(2, context_numBits);\n            context_numBits++;\n        }\n    }\n\n    // Mark the end of the stream\n    value = 2;\n    for (i = 0; i < context_numBits; i++) {\n        context_data_val = (context_data_val << 1) | (value & 1);\n        if (context_data_position == bitsPerChar - 1) {\n            context_data_position = 0;\n            context_data.push(getCharFromInt(context_data_val));\n            context_data_val = 0;\n        } else {\n            context_data_position++;\n        }\n        value = value >> 1;\n    }\n\n    // Flush the last char\n    while (true) {\n        context_data_val = context_data_val << 1;\n        if (context_data_position == bitsPerChar - 1) {\n            context_data.push(getCharFromInt(context_data_val));\n            break;\n        } else context_data_position++;\n    }\n    return context_data.join('');\n}\n\nfunction _decompress(length: number, resetValue: number, getNextValue: (index: number) => number) {\n    let entry = '';\n\n    const dictionary: any[] = [];\n    const result = [];\n    const data = { val: getNextValue(0), position: resetValue, index: 1 };\n\n    let w: string;\n    let next,\n        enlargeIn = 4,\n        dictSize = 4,\n        numBits = 3,\n        i,\n        bits,\n        resb,\n        maxpower,\n        power,\n        c;\n\n    for (i = 0; i < 3; i += 1) {\n        dictionary[i] = i;\n    }\n\n    bits = 0;\n    maxpower = Math.pow(2, 2);\n    power = 1;\n    while (power != maxpower) {\n        resb = data.val & data.position;\n        data.position >>= 1;\n        if (data.position == 0) {\n            data.position = resetValue;\n            data.val = getNextValue(data.index++);\n        }\n        bits |= (resb > 0 ? 1 : 0) * power;\n        power <<= 1;\n    }\n\n    switch ((next = bits)) {\n        case 0:\n            bits = 0;\n            maxpower = Math.pow(2, 8);\n            power = 1;\n            while (power != maxpower) {\n                resb = data.val & data.position;\n                data.position >>= 1;\n                if (data.position == 0) {\n                    data.position = resetValue;\n                    data.val = getNextValue(data.index++);\n                }\n                bits |= (resb > 0 ? 1 : 0) * power;\n                power <<= 1;\n            }\n            c = f(bits);\n            break;\n        case 1:\n            bits = 0;\n            maxpower = Math.pow(2, 16);\n            power = 1;\n            while (power != maxpower) {\n                resb = data.val & data.position;\n                data.position >>= 1;\n                if (data.position == 0) {\n                    data.position = resetValue;\n                    data.val = getNextValue(data.index++);\n                }\n                bits |= (resb > 0 ? 1 : 0) * power;\n                power <<= 1;\n            }\n            c = f(bits);\n            break;\n        case 2:\n            return '';\n    }\n    dictionary[3] = c;\n    w = c;\n    result.push(c);\n    while (true) {\n        if (data.index > length) {\n            return '';\n        }\n\n        bits = 0;\n        maxpower = Math.pow(2, numBits);\n        power = 1;\n        while (power != maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n                data.position = resetValue;\n                data.val = getNextValue(data.index++);\n            }\n            bits |= (resb > 0 ? 1 : 0) * power;\n            power <<= 1;\n        }\n\n        switch ((c = bits)) {\n            case 0:\n                bits = 0;\n                maxpower = Math.pow(2, 8);\n                power = 1;\n                while (power != maxpower) {\n                    resb = data.val & data.position;\n                    data.position >>= 1;\n                    if (data.position == 0) {\n                        data.position = resetValue;\n                        data.val = getNextValue(data.index++);\n                    }\n                    bits |= (resb > 0 ? 1 : 0) * power;\n                    power <<= 1;\n                }\n\n                dictionary[dictSize++] = f(bits);\n                c = dictSize - 1;\n                enlargeIn--;\n                break;\n            case 1:\n                bits = 0;\n                maxpower = Math.pow(2, 16);\n                power = 1;\n                while (power != maxpower) {\n                    resb = data.val & data.position;\n                    data.position >>= 1;\n                    if (data.position == 0) {\n                        data.position = resetValue;\n                        data.val = getNextValue(data.index++);\n                    }\n                    bits |= (resb > 0 ? 1 : 0) * power;\n                    power <<= 1;\n                }\n                dictionary[dictSize++] = f(bits);\n                c = dictSize - 1;\n                enlargeIn--;\n                break;\n            case 2:\n                return result.join('');\n        }\n\n        if (enlargeIn == 0) {\n            enlargeIn = Math.pow(2, numBits);\n            numBits++;\n        }\n\n        if (dictionary[c]) {\n            entry = dictionary[c];\n        } else {\n            if (c === dictSize) {\n                entry = w + w.charAt(0);\n            } else {\n                return null;\n            }\n        }\n        result.push(entry);\n\n        // Add w+entry[0] to the dictionary.\n        dictionary[dictSize++] = w + entry.charAt(0);\n        enlargeIn--;\n\n        w = entry;\n\n        if (enlargeIn == 0) {\n            enlargeIn = Math.pow(2, numBits);\n            numBits++;\n        }\n    }\n}\n","import { MemoEntry } from '../../../memo.types';\nimport { compressToUTF16, decompressFromUTF16 } from '../../../utils/lz-string';\nimport { SimpleLsSerializer } from './ls-serializer';\n\n/**\n * Uses lz-string to compress serialized values in order to save-up some LocalStorage space.\n * @public\n */\nexport class LzMemoSerializer<T = unknown> extends SimpleLsSerializer {\n    deserialize(str: string): Omit<MemoEntry, 'key'> {\n        if (!str) {\n            return null;\n        }\n        return super.deserialize(decompressFromUTF16(str));\n    }\n    serialize(obj: MemoEntry): string {\n        if (!obj) {\n            return null;\n        }\n        return compressToUTF16(super.serialize(obj));\n    }\n}\n","const { toString: toStringFunction } = Function.prototype;\nconst {\n  create,\n  defineProperty,\n  getOwnPropertyDescriptor,\n  getOwnPropertyNames,\n  getOwnPropertySymbols,\n  getPrototypeOf,\n} = Object;\nconst { hasOwnProperty, propertyIsEnumerable } = Object.prototype;\n\n/**\n * @enum\n *\n * @const {Object} SUPPORTS\n *\n * @property {boolean} SYMBOL_PROPERTIES are symbol properties supported\n * @property {boolean} WEAKMAP is WeakMap supported\n */\nexport const SUPPORTS = {\n  SYMBOL_PROPERTIES: typeof getOwnPropertySymbols === 'function',\n  WEAKMAP: typeof WeakMap === 'function',\n};\n\n/**\n * @function createCache\n *\n * @description\n * get a new cache object to prevent circular references\n *\n * @returns the new cache object\n */\nexport const createCache = (): FastCopy.Cache => {\n  if (SUPPORTS.WEAKMAP) {\n    return new WeakMap();\n  }\n\n  // tiny implementation of WeakMap\n  const object = create({\n    has: (key: any) => !!~object._keys.indexOf(key),\n    set: (key: any, value: any) => {\n      object._keys.push(key);\n      object._values.push(value);\n    },\n    get: (key: any) => object._values[object._keys.indexOf(key)],\n  });\n\n  object._keys = [];\n  object._values = [];\n\n  return object;\n};\n\n/**\n * @function getCleanClone\n *\n * @description\n * get an empty version of the object with the same prototype it has\n *\n * @param object the object to build a clean clone from\n * @param realm the realm the object resides in\n * @returns the empty cloned object\n */\nexport const getCleanClone = (object: any, realm: FastCopy.Realm): any => {\n  if (!object.constructor) {\n    return create(null);\n  }\n\n  const { constructor: Constructor } = object;\n  const prototype = object.__proto__ || getPrototypeOf(object);\n\n  if (Constructor === realm.Object) {\n    return prototype === realm.Object.prototype ? {} : create(prototype);\n  }\n\n  if (~toStringFunction.call(Constructor).indexOf('[native code]')) {\n    try {\n      return new Constructor();\n    } catch {}\n  }\n\n  return create(prototype);\n};\n\n/**\n * @function getObjectCloneLoose\n *\n * @description\n * get a copy of the object based on loose rules, meaning all enumerable keys\n * and symbols are copied, but property descriptors are not considered\n *\n * @param object the object to clone\n * @param realm the realm the object resides in\n * @param handleCopy the function that handles copying the object\n * @returns the copied object\n */\nexport const getObjectCloneLoose: FastCopy.ObjectCloner = (\n  object: any,\n  realm: FastCopy.Realm,\n  handleCopy: FastCopy.Copier,\n  cache: FastCopy.Cache,\n): any => {\n  const clone: any = getCleanClone(object, realm);\n  // set in the cache immediately to be able to reuse the object recursively\n  cache.set(object, clone);\n\n  for (const key in object) {\n    if (hasOwnProperty.call(object, key)) {\n      clone[key] = handleCopy(object[key], cache);\n    }\n  }\n\n  if (SUPPORTS.SYMBOL_PROPERTIES) {\n    const symbols: symbol[] = getOwnPropertySymbols(object);\n\n    const { length } = symbols;\n\n    if (length) {\n      for (let index = 0, symbol; index < length; index++) {\n        symbol = symbols[index];\n\n        if (propertyIsEnumerable.call(object, symbol)) {\n          clone[symbol] = handleCopy(object[symbol], cache);\n        }\n      }\n    }\n  }\n\n  return clone;\n};\n\n/**\n * @function getObjectCloneStrict\n *\n * @description\n * get a copy of the object based on strict rules, meaning all keys and symbols\n * are copied based on the original property descriptors\n *\n * @param object the object to clone\n * @param realm the realm the object resides in\n * @param handleCopy the function that handles copying the object\n * @returns the copied object\n */\nexport const getObjectCloneStrict: FastCopy.ObjectCloner = (\n  object: any,\n  realm: FastCopy.Realm,\n  handleCopy: FastCopy.Copier,\n  cache: FastCopy.Cache,\n): any => {\n  const clone: any = getCleanClone(object, realm);\n  // set in the cache immediately to be able to reuse the object recursively\n  cache.set(object, clone);\n\n  const properties: (string | symbol)[] = SUPPORTS.SYMBOL_PROPERTIES\n    ? getOwnPropertyNames(object).concat((getOwnPropertySymbols(object) as unknown) as string[])\n    : getOwnPropertyNames(object);\n\n  const { length } = properties;\n\n  if (length) {\n    for (let index = 0, property, descriptor; index < length; index++) {\n      property = properties[index];\n\n      if (property !== 'callee' && property !== 'caller') {\n        descriptor = getOwnPropertyDescriptor(object, property);\n\n        if (descriptor) {\n          // Only clone the value if actually a value, not a getter / setter.\n          if (!descriptor.get && !descriptor.set) {\n            descriptor.value = handleCopy(object[property], cache);\n          }\n\n          try {\n            defineProperty(clone, property, descriptor);\n          } catch (error) {\n            // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n            clone[property] = descriptor.value;\n          }\n        } else {\n          // In extra edge cases where the property descriptor cannot be retrived, fall back to\n          // the loose assignment.\n          clone[property] = handleCopy(object[property], cache);\n        }\n      }\n    }\n  }\n\n  return clone;\n};\n\n/**\n * @function getRegExpFlags\n *\n * @description\n * get the flags to apply to the copied regexp\n *\n * @param regExp the regexp to get the flags of\n * @returns the flags for the regexp\n */\nexport const getRegExpFlags = (regExp: RegExp): string => {\n  let flags = '';\n\n  if (regExp.global) {\n    flags += 'g';\n  }\n\n  if (regExp.ignoreCase) {\n    flags += 'i';\n  }\n\n  if (regExp.multiline) {\n    flags += 'm';\n  }\n\n  if (regExp.unicode) {\n    flags += 'u';\n  }\n\n  if (regExp.sticky) {\n    flags += 'y';\n  }\n\n  return flags;\n};\n","// utils\nimport { createCache, getObjectCloneLoose, getObjectCloneStrict, getRegExpFlags } from './utils';\n\nconst { isArray } = Array;\n\nconst GLOBAL_THIS = (() => {\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  if (console && console.error) {\n    console.error('Unable to locate global object, returning \"this\".');\n  }\n})();\n\n/**\n * @function copy\n *\n * @description\n * copy an object deeply as much as possible\n *\n * If `strict` is applied, then all properties (including non-enumerable ones)\n * are copied with their original property descriptors on both objects and arrays.\n *\n * The object is compared to the global constructors in the `realm` provided,\n * and the native constructor is always used to ensure that extensions of native\n * objects (allows in ES2015+) are maintained.\n *\n * @param object the object to copy\n * @param [options] the options for copying with\n * @param [options.isStrict] should the copy be strict\n * @param [options.realm] the realm (this) object the object is copied from\n * @returns the copied object\n */\nfunction copy<T>(object: T, options?: FastCopy.Options): T {\n  // manually coalesced instead of default parameters for performance\n  const isStrict: boolean = !!(options && options.isStrict);\n  const realm: FastCopy.Realm = (options && options.realm) || GLOBAL_THIS;\n\n  const getObjectClone: FastCopy.ObjectCloner = isStrict\n    ? getObjectCloneStrict\n    : getObjectCloneLoose;\n\n  /**\n   * @function handleCopy\n   *\n   * @description\n   * copy the object recursively based on its type\n   *\n   * @param object the object to copy\n   * @returns the copied object\n   */\n  const handleCopy: FastCopy.Copier = (object: any, cache: FastCopy.Cache): any => {\n    if (!object || typeof object !== 'object') {\n      return object;\n    } if (cache.has(object)) {\n      return cache.get(object);\n    }\n\n    const { constructor: Constructor } = object;\n\n    // plain objects\n    if (Constructor === realm.Object) {\n      return getObjectClone(object, realm, handleCopy, cache);\n    }\n\n    let clone: any;\n    // arrays\n    if (isArray(object)) {\n      // if strict, include non-standard properties\n      if (isStrict) {\n        return getObjectCloneStrict(object, realm, handleCopy, cache);\n      }\n\n      const { length } = object;\n\n      clone = new Constructor();\n      cache.set(object, clone);\n\n      for (let index: number = 0; index < length; index++) {\n        clone[index] = handleCopy(object[index], cache);\n      }\n\n      return clone;\n    }\n\n    // dates\n    if (object instanceof realm.Date) {\n      return new Constructor(object.getTime());\n    }\n\n    // regexps\n    if (object instanceof realm.RegExp) {\n      clone = new Constructor(object.source, object.flags || getRegExpFlags(object));\n\n      clone.lastIndex = object.lastIndex;\n\n      return clone;\n    }\n\n    // maps\n    if (realm.Map && object instanceof realm.Map) {\n      clone = new Constructor();\n      cache.set(object, clone);\n\n      object.forEach((value: any, key: any) => {\n        clone.set(key, handleCopy(value, cache));\n      });\n\n      return clone;\n    }\n\n    // sets\n    if (realm.Set && object instanceof realm.Set) {\n      clone = new Constructor();\n      cache.set(object, clone);\n\n      object.forEach((value: any) => {\n        clone.add(handleCopy(value, cache));\n      });\n\n      return clone;\n    }\n\n    // blobs\n    if (realm.Blob && object instanceof realm.Blob) {\n      return object.slice(0, object.size, object.type);\n    }\n\n    // buffers (node-only)\n    if (realm.Buffer && realm.Buffer.isBuffer(object)) {\n      clone = realm.Buffer.allocUnsafe\n        ? realm.Buffer.allocUnsafe(object.length)\n        : new Constructor(object.length);\n\n      cache.set(object, clone);\n      object.copy(clone);\n\n      return clone;\n    }\n\n    // arraybuffers / dataviews\n    if (realm.ArrayBuffer) {\n      // dataviews\n      if (realm.ArrayBuffer.isView(object)) {\n        clone = new Constructor(object.buffer.slice(0));\n        cache.set(object, clone);\n        return clone;\n      }\n\n      // arraybuffers\n      if (object instanceof realm.ArrayBuffer) {\n        clone = object.slice(0);\n        cache.set(object, clone);\n        return clone;\n      }\n    }\n\n    // if the object cannot / should not be cloned, don't\n    if (\n      // promise-like\n      typeof object.then === 'function' ||\n      // errors\n      object instanceof Error ||\n      // weakmaps\n      (realm.WeakMap && object instanceof realm.WeakMap) ||\n      // weaksets\n      (realm.WeakSet && object instanceof realm.WeakSet)\n    ) {\n      return object;\n    }\n\n    // assume anything left is a custom constructor\n    return getObjectClone(object, realm, handleCopy, cache);\n  };\n\n  return handleCopy(object, createCache());\n}\n\n// Adding reference to allow usage in CommonJS libraries compiled using TSC, which\n// expects there to be a default property on the exported object. See\n// [#37](https://github.com/planttheidea/fast-copy/issues/37) for details.\ncopy.default = copy;\n\n/**\n * @function strictCopy\n *\n * @description\n * copy the object with `strict` option pre-applied\n *\n * @param object the object to copy\n * @param [options] the options for copying with\n * @param [options.realm] the realm (this) object the object is copied from\n * @returns the copied object\n */\ncopy.strict = function strictCopy(object: any, options?: FastCopy.Options) {\n  return copy(object, {\n    isStrict: true,\n    realm: options ? options.realm : void 0,\n  });\n};\n\nexport default copy;\n","import { assert } from '@aspectjs/core/utils';\nimport { MemoFrame } from '../../drivers';\nimport { MarshalFn, MemoMarshaller, UnmarshalFn } from './marshaller';\nimport { MarshallingContext, UnmarshallingContext } from '../marshalling-context';\n\n/**\n * Supports marshalling simple objects\n * @public\n */\nexport class ObjectMarshaller extends MemoMarshaller {\n    readonly types = ['Object', 'object'];\n\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    marshal(frame: MemoFrame<object>, context: MarshallingContext, defaultMarshal: MarshalFn): MemoFrame<object> {\n        if (!frame.value) {\n            return frame;\n        }\n        return frame.setValue(\n            ([] as (string | symbol)[])\n                .concat(Object.getOwnPropertyNames(frame.value))\n                .concat(Object.getOwnPropertySymbols(frame.value))\n                .reduce((w, k) => {\n                    const v = (frame.value as any)[k];\n\n                    w[k] = defaultMarshal(v);\n\n                    return w;\n                }, {} as any),\n        );\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    unmarshal(frame: MemoFrame<object>, context: UnmarshallingContext, defaultUnmarshal: UnmarshalFn): object {\n        if (frame.value === null) {\n            return null;\n        }\n        const value: any = {};\n        context.blacklist.set(frame, value);\n        assert(!!frame.value);\n        return ([] as (string | symbol)[])\n            .concat(Object.getOwnPropertyNames(frame.value))\n            .concat(Object.getOwnPropertySymbols(frame.value))\n            .reduce((v, k) => {\n                v[k] = defaultUnmarshal((frame.value as any)[k]);\n                return v;\n            }, value as any);\n    }\n}\n","import { WEAVER_CONTEXT } from '@aspectjs/core';\nimport { assert, isUndefined } from '@aspectjs/core/utils';\nimport { WeavingError } from '@aspectjs/core/commons';\nimport { Cacheable } from '../../cacheable/cacheable.annotation';\nimport { MemoFrame } from '../../drivers';\nimport { VersionConflictError } from '../../errors';\nimport { CacheableAspect, CacheTypeStore } from '../../cacheable/cacheable.aspect';\nimport { MarshalFn, MemoMarshaller } from './marshaller';\nimport { ObjectMarshaller } from './object-marshaller';\nimport { MarshallingContext, UnmarshallingContext } from '../marshalling-context';\nimport { provider, hash } from '../../utils';\n\n/**\n * Supports marshalling instances of classes annotated with @Cacheable\n * @public\n */\nexport class CacheableMarshaller extends MemoMarshaller {\n    readonly types = '*';\n    private _objectMarshaller: ObjectMarshaller;\n    private _nonCacheableHandler: (proto: object) => void;\n\n    constructor(options?: { objectMarshaller: ObjectMarshaller; nonCacheableHandler: (proto: object) => void }) {\n        super();\n        this._objectMarshaller = options?.objectMarshaller ?? new ObjectMarshaller();\n        this._nonCacheableHandler =\n            options?.nonCacheableHandler ??\n            ((proto) => {\n                const name = proto.constructor.name;\n                throw new TypeError(\n                    `Type \"${name}\" is not annotated with \"${Cacheable}\". Please add \"${Cacheable}\" on class \"${name}\", or register a proper ${MemoMarshaller.name} for this type.`,\n                );\n            });\n    }\n    marshal(frame: MemoFrame<object>, context: MarshallingContext, defaultMarshal: MarshalFn): MemoFrame {\n        // delete wrap.type; // Do not store useless type, as INSTANCE_TYPE is used for objects of non-built-in types.\n        const proto = Reflect.getPrototypeOf(frame.value);\n\n        const ts = typeStore();\n        const instanceType = ts.getTypeKey(proto);\n\n        if (!instanceType) {\n            this._nonCacheableHandler(proto);\n        }\n\n        const newFrame = this._objectMarshaller.marshal(frame, context, defaultMarshal);\n\n        newFrame.hash = __createHash(proto);\n        newFrame.instanceType = instanceType;\n        newFrame.version = provider(ts.getVersion(instanceType))();\n\n        return newFrame;\n    }\n    unmarshal(frame: MemoFrame<object>, context: UnmarshallingContext, defaultUnmarshal: MarshalFn): any {\n        frame.value = this._objectMarshaller.unmarshal(frame, context, defaultUnmarshal);\n\n        assert(!!frame.instanceType);\n        const ts = typeStore();\n        const proto = ts.getPrototype(frame.instanceType);\n        const version = provider(ts.getVersion(frame.instanceType))();\n        if (version !== frame.version) {\n            if (version !== frame.version) {\n                throw new VersionConflictError(\n                    `Object for key ${frame.instanceType} is of version ${version}, but incompatible version ${frame.version} was already cached`,\n                    context,\n                );\n            }\n        }\n        if (version === undefined && frame.hash !== __createHash(proto)) {\n            throw new VersionConflictError(`Hash changed for type ${frame.instanceType} `, context);\n        }\n        Reflect.setPrototypeOf(frame.value, proto);\n\n        return frame.value;\n    }\n}\n\nfunction typeStore(): CacheTypeStore {\n    const weaver = WEAVER_CONTEXT.getWeaver();\n    if (!weaver) {\n        throw new WeavingError('no weaver configured. Please call setWeaver()');\n    }\n\n    const cacheableAspect = weaver.getAspect('@aspectjs/cacheable') as CacheableAspect;\n\n    if (!cacheableAspect) {\n        throw new WeavingError(\n            'MemoAspect requires an aspect to be registered for id \"@aspectjs/cacheable\".' +\n                ' Did you forgot to call getWeaver().enable(new DefaultCacheableAspect()) ?',\n        );\n    }\n\n    return cacheableAspect.cacheTypeStore;\n}\n\nfunction __createHash(proto: object): string {\n    const s: string[] = [];\n    let p = proto;\n    while (p !== Object.prototype) {\n        s.push(p.constructor.toString());\n        p = Reflect.getPrototypeOf(p);\n    }\n    return hash(s.join());\n}\n","import { MemoFrame } from '../../drivers';\nimport { MarshalFn, MemoMarshaller, UnmarshalFn } from './marshaller';\nimport { MarshallingContext, UnmarshallingContext } from '../marshalling-context';\n\n/**\n * Supports marshalling arrays\n * @public\n */\nexport class ArrayMarshaller extends MemoMarshaller {\n    readonly types = 'Array';\n\n    marshal(frame: MemoFrame<unknown[]>, context: MarshallingContext, defaultMarshal: MarshalFn): MemoFrame<any[]> {\n        // array may contain promises\n        frame.value = frame.value.map((i) => defaultMarshal(i));\n\n        return frame;\n    }\n    unmarshal(frame: MemoFrame<unknown[]>, context: UnmarshallingContext, defaultUnmarshal: UnmarshalFn): unknown[] {\n        // assert(wrapped[F.TYPE] === ValueType.ARRAY);\n        const value = [] as any[];\n\n        context.blacklist.set(frame, value);\n        value.push(...((frame.value as any) as any[]).map((w) => defaultUnmarshal(w)));\n        return value;\n    }\n}\n","import { MemoFrame } from '../../drivers';\nimport { MemoMarshaller } from './marshaller';\n\n/**\n * Supports marshalling primitives\n * @public\n */\nexport class BasicMarshaller extends MemoMarshaller<any> {\n    readonly types = ['Number', 'String', 'Boolean', 'symbol', 'number', 'string', 'boolean', 'symbol', 'undefined'];\n\n    marshal<T>(frame: MemoFrame<T>): MemoFrame<T> {\n        return frame;\n    }\n    unmarshal<T>(frame: MemoFrame<T>): T {\n        return frame.value;\n    }\n}\n","import { MemoFrame } from '../../drivers';\nimport { parse, stringify } from 'flatted';\nimport { MemoMarshaller } from './marshaller';\n\n/**\n * Supports marshalling Dates\n * @public\n */\nexport class DateMarshaller extends MemoMarshaller<Date, string> {\n    readonly types = 'Date';\n\n    marshal(frame: MemoFrame<Date>): MemoFrame<string> {\n        return frame.setValue(stringify(frame.value));\n    }\n\n    unmarshal(frame: MemoFrame<string>): Date {\n        return new Date(parse(frame.value as any));\n    }\n}\n","import { MemoFrame } from '../../drivers';\nimport { MemoMarshaller } from './marshaller';\n\n/**\n * Pass-through marshaller\n * @public\n */\nexport abstract class NoopMarshaller extends MemoMarshaller {\n    marshal<T>(value: T): MemoFrame<T> {\n        return new MemoFrame<T>({\n            value,\n        });\n    }\n    unmarshal<T>(frame: MemoFrame<T>): T {\n        return frame.value;\n    }\n}\n","import { MemoFrame } from '../../drivers';\nimport { MarshalFn, MemoMarshaller, UnmarshalFn } from './marshaller';\nimport { MarshallingContext, UnmarshallingContext } from '../marshalling-context';\n\n/**\n * Supports marshalling promises\n * @public\n */\nexport class PromiseMarshaller extends MemoMarshaller<Promise<any>, any> {\n    readonly types = 'Promise';\n\n    marshal(\n        frame: MemoFrame<Promise<unknown>>,\n        context: MarshallingContext,\n        defaultMarshal: MarshalFn,\n    ): MemoFrame<Promise<any>> {\n        frame.setAsyncValue(frame.value.then((v) => defaultMarshal(v)));\n        return frame;\n    }\n\n    unmarshal(\n        frame: MemoFrame<MemoFrame<any>>,\n        context: UnmarshallingContext,\n        defaultUnmarshal: UnmarshalFn,\n    ): Promise<any> {\n        if (frame.isAsync()) {\n            return frame.async.then((v) => {\n                return defaultUnmarshal(v);\n            });\n        } else {\n            return Promise.resolve(defaultUnmarshal(frame.value));\n        }\n    }\n}\n","import { assert, isArray, isObject } from '@aspectjs/core/utils';\nimport { MemoFrame } from '../drivers';\nimport { InstantPromise } from '../utils';\nimport { MemoMarshaller } from './marshallers';\nimport { MarshallingContext, UnmarshallingContext } from './marshalling-context';\n\nexport class MarshallersRegistry {\n    private _marshallers: Record<string, MemoMarshaller> = {};\n\n    addMarshaller(...marshallers: MemoMarshaller[]): this {\n        (marshallers ?? []).forEach((marshaller) => {\n            [marshaller.types].flat().forEach((type: string) => {\n                this._marshallers[type] = marshaller;\n            });\n        });\n\n        return this;\n    }\n\n    removeMarshaller(...marshallers: MemoMarshaller[]): this {\n        (marshallers ?? []).forEach((marshaller) => {\n            [marshaller.types].flat().forEach((type: string) => {\n                delete this._marshallers[type];\n            });\n        });\n\n        return this;\n    }\n\n    getMarshaller(typeName: string): MemoMarshaller {\n        const marshaller = this._marshallers[typeName] ?? this._marshallers['*'];\n\n        if (!marshaller) {\n            throw new TypeError(`No marshaller to handle value of type ${typeName}`);\n        }\n\n        return marshaller;\n    }\n\n    marshal<T>(value: T): MarshallingContext<T> {\n        return new MarshallingContextImpl(this, value);\n    }\n\n    unmarshal(frame: MemoFrame<any>): UnmarshallingContext<any> {\n        return new UnmarshallingContextImpl(this, frame).frame.value;\n    }\n}\n\nclass MarshallingContextImpl<T> implements MarshallingContext<T> {\n    private _blacklist: Map<any, MemoFrame<T>> = new Map<any, MemoFrame<T>>();\n    private readonly _promises: Promise<any>[] = [];\n    readonly frame: MemoFrame<T>;\n\n    constructor(private readonly _marshallersRegistry: MarshallersRegistry, public readonly value: T) {\n        this.frame = this._defaultMarshal(this.value);\n    }\n\n    private _defaultMarshal(value: T): MemoFrame<T> {\n        if (this._blacklist.has(value)) {\n            return this._blacklist.get(value);\n        }\n\n        const type = value?.constructor.name ?? typeof value;\n        const marshaller = this._marshallersRegistry.getMarshaller(type);\n\n        const baseFrame = new MemoFrame<T>({ value, type });\n        if (isObject(value) || isArray(value)) {\n            this._blacklist.set(value, baseFrame);\n        }\n\n        const frame = marshaller.marshal(baseFrame, this, this._defaultMarshal.bind(this));\n        if (frame.isAsync()) {\n            this._promises.push(frame.async);\n        }\n        return frame;\n    }\n\n    then<TResult1 = T, TResult2 = never>(\n        onfulfilled?: ((value: MemoFrame<T>) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n    ): PromiseLike<TResult1> {\n        return InstantPromise.all(...this._promises)\n            .then(() => this.frame)\n            .then(onfulfilled, onrejected) as PromiseLike<TResult1>;\n    }\n}\n\nclass UnmarshallingContextImpl<T = unknown> implements UnmarshallingContext<T> {\n    readonly blacklist?: Map<MemoFrame, any> = new Map<MemoFrame, any>();\n\n    constructor(private readonly _marshallersRegistry: MarshallersRegistry, public readonly frame: MemoFrame<T>) {\n        this._defaultUnmarshal(this.frame);\n    }\n\n    _defaultUnmarshal<T>(frame: MemoFrame<T>): T {\n        assert(!!frame);\n        if (this.blacklist.has(frame)) {\n            return this.blacklist.get(frame);\n        }\n\n        if (!frame) {\n            return null;\n        }\n        if (!(frame instanceof MemoFrame)) {\n            Reflect.setPrototypeOf(frame, MemoFrame.prototype);\n        }\n\n        assert(!!frame.type);\n        const typeName = frame.type ?? '*';\n\n        const marshaller = this._marshallersRegistry.getMarshaller(typeName);\n\n        frame.value = marshaller.unmarshal(frame, this, this._defaultUnmarshal.bind(this));\n        return frame.value;\n    }\n}\n","import { Around, Aspect } from '@aspectjs/core/annotations';\nimport { AroundContext, AspectError, AspectType, BeforeContext, JoinPoint, on } from '@aspectjs/core/commons';\nimport { getOrComputeMetadata, getProto, isFunction, isString, isUndefined } from '@aspectjs/core/utils';\nimport copy from 'fast-copy';\n\nimport { stringify } from 'flatted';\n\nimport { MemoDriver, MemoFrame } from './drivers';\nimport { MemoAspectError, VersionConflictError } from './errors';\nimport {\n    ArrayMarshaller,\n    BasicMarshaller,\n    CacheableMarshaller,\n    DateMarshaller,\n    MemoMarshaller,\n    ObjectMarshaller,\n    PromiseMarshaller,\n} from './marshalling/marshallers';\nimport { MarshallersRegistry } from './marshalling/marshallers-registry';\nimport { Memo, MemoOptions } from './memo.annotation';\nimport { MemoEntry, MemoKey } from './memo.types';\nimport { hash, Mutable, provider } from './utils';\n\n/**\n * @public marshallers that gets configured with default MemoAspect\n */\nexport const DEFAULT_MARSHALLERS: MemoMarshaller[] = [\n    new ObjectMarshaller(),\n    new ArrayMarshaller(),\n    new DateMarshaller(),\n    new PromiseMarshaller(),\n    new CacheableMarshaller(),\n    new BasicMarshaller(),\n];\nObject.freeze(DEFAULT_MARSHALLERS);\n\nconst MEMO_ID_REFLECT_KEY = '@aspectjs:memo/id';\nlet internalId = 0;\n\n/**\n * Options accepted by MemoAspect\n * @public\n */\n\nexport interface MemoAspectOptions {\n    /** use a namespace to avoid collision of data between eg: 2 different users */\n    namespace?: string | (() => string);\n    /** configure cache expiration in milliseconds or at a given specific date */\n    expiration?: Date | number | (() => Date | number);\n    /** get the identity of the class whose methods generates memoized data */\n    id?: string | number | ((ctxt: BeforeContext<any, any>) => string | number);\n    /** function that based on the execution context, generates the key to store cached data  */\n    createMemoKey?: (ctxt: BeforeContext<any, any>) => MemoKey | string;\n    /** marshallers to transform objects from / to storable structure */\n    marshallers?: MemoMarshaller[];\n    /** drivers that do the actual storage **/\n    drivers?: MemoDriver[];\n}\n\nconst DEFAULT_MEMO_ASPECT_OPTIONS: Required<MemoAspectOptions> = {\n    id: (ctxt: BeforeContext<any>) => {\n        const { id, _id, hashcode, _hashcode } = ctxt.instance;\n        const result = id ?? _id ?? hashcode ?? _hashcode;\n        if (isUndefined(result)) {\n            return getOrComputeMetadata(MEMO_ID_REFLECT_KEY, ctxt.instance, () => internalId++);\n        }\n        return result;\n    },\n    namespace: '',\n    createMemoKey: (ctxt: BeforeContext<any>) => {\n        return new MemoKey({\n            namespace: ctxt.data.namespace,\n            instanceId: ctxt.data.instanceId,\n            argsKey: hash(stringify(ctxt.args)),\n            targetKey: hash(`${ctxt.target.ref}`),\n        });\n    },\n    expiration: undefined,\n    marshallers: DEFAULT_MARSHALLERS,\n    drivers: [],\n};\n\n/**\n * Enable Memoization of a method's return value.\n * @public\n */\n@Aspect('@aspectjs/memo')\nexport class MemoAspect implements AspectType {\n    protected _options: MemoAspectOptions;\n    private readonly _drivers: Record<string, MemoDriver> = {};\n    /** maps memo keys with its unregister function for garbage collector timeouts */\n    private readonly _entriesGc: Map<string, number> = new Map();\n    private _marshallers: MarshallersRegistry;\n    private _pendingResults: Map<string, any> = new Map();\n    private _enabled: boolean;\n\n    constructor(params?: MemoAspectOptions) {\n        this._options = { ...DEFAULT_MEMO_ASPECT_OPTIONS, ...params };\n        this._marshallers = new MarshallersRegistry();\n        this.addMarshaller(...DEFAULT_MARSHALLERS, ...(this._options.marshallers ?? []));\n        this.addDriver(...(params?.drivers ?? []));\n    }\n\n    getDrivers(): Record<string, MemoDriver> {\n        return this._drivers;\n    }\n\n    public addDriver(...drivers: MemoDriver[]): this {\n        (drivers ?? []).forEach((d) => {\n            const existingDriver = this._drivers[d.NAME];\n            if (existingDriver === d) {\n                return;\n            }\n            if (existingDriver) {\n                throw new Error(\n                    `both ${d.constructor?.name} & ${existingDriver.constructor?.name} configured for name ${d.NAME}`,\n                );\n            }\n            this._drivers[d.NAME] = d;\n            if (this._enabled) {\n                this._initGc(d);\n            }\n        });\n        return this;\n    }\n\n    onEnable(): void {\n        this._enabled = true;\n        Object.values(this._drivers).forEach((d) => this._initGc(d));\n    }\n\n    addMarshaller(...marshallers: MemoMarshaller[]): void {\n        this._marshallers.addMarshaller(...marshallers);\n    }\n\n    removeMarshaller(...marshallers: MemoMarshaller[]): void {\n        this._marshallers.removeMarshaller(...marshallers);\n    }\n\n    /**\n     * Apply the memo pattern. That is, get the result from cache if any, or call the original method and store the result otherwise.\n     */\n    @Around(on.method.withAnnotations(Memo))\n    applyMemo(ctxt: AroundContext<any>, jp: JoinPoint): any {\n        const memoParams = ctxt.annotations.onSelf(Memo)[0].args[0] as MemoOptions;\n        ctxt.data.namespace = provider(memoParams?.namespace)() ?? provider(this._options?.namespace)();\n        ctxt.data.instanceId = `${provider(memoParams?.id)(ctxt) ?? provider(this._options?.id)(ctxt)}`;\n        const key = this._options.createMemoKey(ctxt) as MemoKey;\n\n        if (!key) {\n            throw new Error(`${this._options.createMemoKey.name} function did not return a valid MemoKey`);\n        }\n\n        const options = ctxt.annotations.onSelf(Memo)[0].args[0] as MemoOptions;\n        const expiration = this.getExpiration(ctxt, options);\n        const drivers = _selectCandidateDrivers(this._drivers, ctxt);\n\n        const proceedJoinpoint = () => {\n            // value not cached. Call the original method\n            const value = jp();\n            this._pendingResults.set(key.toString(), value);\n\n            // marshall the value into a frame\n            const marshallingContext = this._marshallers.marshal(value);\n\n            const driver = drivers\n                .filter((d) => d.accepts(marshallingContext))\n                .map((d) => [d, d.getPriority(marshallingContext)])\n                .sort((dp1: any, dp2: any) => dp2[1] - dp1[1])\n                .map((dp) => dp[0])[0] as MemoDriver;\n\n            if (!driver) {\n                throw new AspectError(\n                    ctxt,\n                    `Driver ${drivers[0].NAME} does not accept value of type ${\n                        getProto(value)?.constructor?.name ?? typeof value\n                    } returned by ${ctxt.target.label}`,\n                );\n            }\n\n            if (expiration) {\n                this._scheduleCleaner(driver, key, expiration);\n            }\n\n            marshallingContext.then((frame: MemoFrame<any>) => {\n                // promise resolution may not arrive in time in case the same method is called right after.\n                // store the result in a temporary variable in order to be available right away\n                const entry = {\n                    key,\n                    expiration,\n                    frame,\n                    signature: __createContextSignature(ctxt),\n                } as Mutable<MemoEntry>;\n\n                driver.write(entry).then(() => {\n                    const pendingResults = this._pendingResults.get(key.toString());\n\n                    if (pendingResults === value) {\n                        this._pendingResults.delete(key.toString());\n                    }\n                });\n            });\n            return value;\n        };\n        const pendingResults = this._pendingResults.get(key.toString());\n        if (pendingResults) {\n            return copy(pendingResults);\n        }\n        for (const d of drivers) {\n            try {\n                const entry = d.read(key);\n                if (entry) {\n                    if (entry.expiration && entry.expiration < new Date()) {\n                        // remove data if expired\n                        this._removeValue(d, key);\n                    } else if (entry.signature && entry.signature !== __createContextSignature(ctxt)) {\n                        // remove data if signature mismatch\n                        console.debug(`${ctxt.target.label} hash mismatch. Removing memoized data...`);\n                        this._removeValue(d, key);\n                    } else {\n                        return this._marshallers.unmarshal(entry.frame);\n                    }\n                }\n            } catch (e) {\n                // mute errors in ase of version mismatch, & just remove old version\n                if (e instanceof VersionConflictError || e instanceof MemoAspectError) {\n                    console.error(e);\n                    this._removeValue(d, key);\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // found no driver for this value. Call the real method\n        return proceedJoinpoint();\n    }\n\n    private _removeValue(driver: MemoDriver, key: MemoKey): void {\n        driver.remove(key);\n        // get gc timeout handle\n        const t = this._entriesGc.get(key.toString());\n        this._pendingResults.delete(key.toString());\n\n        if (t !== undefined) {\n            // this entry is not eligible for gc\n            this._entriesGc.delete(key.toString());\n\n            // remove gc timeout\n            clearTimeout(t as number);\n        }\n    }\n\n    private _scheduleCleaner(driver: MemoDriver, key: MemoKey, expiration: Date): void {\n        const ttl = expiration.getTime() - new Date().getTime();\n        if (ttl <= 0) {\n            this._removeValue(driver, key);\n        } else {\n            this._entriesGc.set(key.toString(), setTimeout(() => this._removeValue(driver, key), ttl) as any);\n        }\n    }\n\n    private _initGc(driver: MemoDriver): void {\n        driver.getKeys().then((keys) => {\n            keys.forEach((k) => {\n                Promise.resolve(driver.read(k)).then((memo) => {\n                    if (memo?.expiration) {\n                        this._scheduleCleaner(driver, k, memo.expiration);\n                    }\n                });\n            });\n        });\n    }\n\n    private getExpiration(ctxt: AroundContext<any>, options: MemoOptions): Date | undefined {\n        const exp = provider(options?.expiration)();\n        if (exp) {\n            if (exp instanceof Date) {\n                return exp;\n            } else if (typeof exp === 'number' && exp > 0) {\n                return new Date(new Date().getTime() + exp * 1000);\n            } else if (exp === 0) {\n                return;\n            }\n\n            throw new AspectError(ctxt, `expiration should be either a Date or a positive number. Got: ${exp}`);\n        }\n    }\n}\n\nfunction _selectCandidateDrivers(drivers: Record<string, MemoDriver>, ctxt: AroundContext<any, any>): MemoDriver[] {\n    const annotationOptions = (ctxt.annotations.onSelf(Memo)[0].args[0] ?? {}) as MemoOptions;\n    if (!annotationOptions.driver) {\n        // return all drivers\n        return Object.values(drivers);\n    } else {\n        if (isString(annotationOptions.driver)) {\n            const candidates = Object.values(drivers).filter((d) => d.NAME === annotationOptions.driver);\n            if (!candidates.length) {\n                throw new AspectError(\n                    ctxt,\n                    `No candidate driver available for driver name \"${annotationOptions.driver}\"`,\n                );\n            }\n\n            return candidates;\n        } else if (isFunction(annotationOptions.driver)) {\n            const candidates = Object.values(drivers).filter((d) => d.constructor === annotationOptions.driver);\n            if (!candidates.length) {\n                throw new AspectError(\n                    ctxt,\n                    `No candidate driver available for driver \"${annotationOptions.driver?.name}\"`,\n                );\n            }\n            return candidates;\n        } else {\n            throw new AspectError(\n                ctxt,\n                `driver option should be a string or a Driver constructor. Got: ${annotationOptions.driver}`,\n            );\n        }\n    }\n}\n\nfunction __createContextSignature(ctxt: AroundContext<unknown>) {\n    const s: string[] = [];\n    let proto = ctxt.target.proto as any;\n    let property = proto[ctxt.target.propertyKey];\n    while (proto !== Object.prototype && property) {\n        s.push(ctxt.target.proto[ctxt.target.propertyKey].toString());\n        proto = Reflect.getPrototypeOf(proto);\n        property = proto[ctxt.target.propertyKey];\n    }\n\n    return hash(s.join());\n}\n","import { WeaverProfile } from '@aspectjs/core/commons';\nimport { DefaultCacheableAspect } from '../cacheable/cacheable.aspect';\nimport { IdbMemoDriver, LsMemoDriver, LsMemoSerializer, LzMemoSerializer, MemoDriver } from '../drivers';\nimport { DEFAULT_MARSHALLERS, MemoAspect, MemoAspectOptions } from '../memo.aspect';\n\n/**\n * @public\n */\nexport interface MemoProfileFeatures {\n    useLocalStorage?: boolean;\n    useIndexedDb?: boolean;\n    useLzString?: boolean;\n    options?: MemoAspectOptions;\n}\n\n/**\n * Weaver profile configured with\n * - LsMemoAspect (for synchronous @Memo methods)\n *     - LzMemoHandler to compress data stored in LocalStorage\n * - IndexedDbMemoAspect (for asynchronous @Memo methods)\n * @public\n */\nexport class MemoProfile extends WeaverProfile {\n    protected _features: MemoProfileFeatures = {\n        useLocalStorage: true,\n        useIndexedDb: true,\n        useLzString: true,\n        options: {},\n    };\n    constructor(memoProfileFeatures?: MemoProfileFeatures) {\n        super();\n\n        this.enable(new DefaultCacheableAspect());\n        this._features.options = memoProfileFeatures?.options ?? this._features.options;\n        this._features.useIndexedDb = memoProfileFeatures?.useIndexedDb ?? this._features.useIndexedDb;\n        this._features.useLzString = memoProfileFeatures?.useLzString ?? this._features.useLzString;\n        this._features.useLocalStorage = memoProfileFeatures?.useLocalStorage ?? this._features.useLocalStorage;\n\n        const marshallers = [...DEFAULT_MARSHALLERS];\n        const drivers: MemoDriver[] = [];\n\n        if (this._features.useIndexedDb) {\n            drivers.push(new IdbMemoDriver());\n        }\n\n        if (this._features.useLocalStorage) {\n            let serializer: LsMemoSerializer;\n            if (this._features.useLzString) {\n                serializer = new LzMemoSerializer();\n            }\n            drivers.push(\n                new LsMemoDriver({\n                    serializer,\n                }),\n            );\n        }\n\n        const memoAspect = new MemoAspect({\n            ...this._features.options,\n            marshallers,\n            drivers,\n        });\n\n        this.enable(memoAspect);\n    }\n\n    public configure(features: MemoProfileFeatures): MemoProfile {\n        return new MemoProfile({ ...this._features, ...features });\n    }\n}\n","import { WEAVER_CONTEXT } from '@aspectjs/core';\nimport { MemoProfile, MemoProfileFeatures } from './profiles/default.profile';\n\n/**\n * @public\n */\nclass DefaultMemoProfile extends MemoProfile {\n    register() {\n        WEAVER_CONTEXT.getWeaver().enable(this);\n    }\n\n    configure(features: MemoProfileFeatures): DefaultMemoProfile {\n        return new DefaultMemoProfile({ ...this._features, ...features });\n    }\n}\n\n/**\n * @public\n */\nexport const MEMO_PROFILE = new DefaultMemoProfile();\n"],"names":["__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","__decorate","decorators","target","key","desc","c","arguments","r","getOwnPropertyDescriptor","d","Reflect","decorate","defineProperty","__metadata","metadataKey","metadataValue","metadata","on","$parse","JSON","parse","$stringify","stringify","keys","Primitive","String","primitive","ignore","object","noop","_","value","primitives","Primitives","revive","input","parsed","output","$","lazy","ke","y","k","tmp","has","add","push","a","apply","set","known","index","text","reviver","map","Set","replacer","space","v","Map","firstRun","replace","join","after","get","isUndefined","isArray","WeaverProfile"],"mappings":"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"}