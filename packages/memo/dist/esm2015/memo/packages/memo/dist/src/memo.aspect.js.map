{"version":3,"file":"memo.aspect.js","sources":["../../../../../../../src/memo.aspect.ts"],"sourcesContent":["import { Around, Aspect } from '@aspectjs/core/annotations';\nimport { AroundContext, AspectError, AspectType, BeforeContext, JoinPoint, on } from '@aspectjs/core/commons';\nimport { getOrComputeMetadata, getProto, isFunction, isString, isUndefined } from '@aspectjs/core/utils';\nimport copy from 'fast-copy';\n\nimport { stringify } from 'flatted';\n\nimport { MemoDriver, MemoFrame } from './drivers';\nimport { MemoAspectError, VersionConflictError } from './errors';\nimport {\n    ArrayMarshaller,\n    BasicMarshaller,\n    CacheableMarshaller,\n    DateMarshaller,\n    MemoMarshaller,\n    ObjectMarshaller,\n    PromiseMarshaller,\n} from './marshalling/marshallers';\nimport { MarshallersRegistry } from './marshalling/marshallers-registry';\nimport { Memo, MemoOptions } from './memo.annotation';\nimport { MemoEntry, MemoKey } from './memo.types';\nimport { hash, Mutable, provider } from './utils';\n\n/**\n * @public marshallers that gets configured with default MemoAspect\n */\nexport const DEFAULT_MARSHALLERS: MemoMarshaller[] = [\n    new ObjectMarshaller(),\n    new ArrayMarshaller(),\n    new DateMarshaller(),\n    new PromiseMarshaller(),\n    new CacheableMarshaller(),\n    new BasicMarshaller(),\n];\nObject.freeze(DEFAULT_MARSHALLERS);\n\nconst MEMO_ID_REFLECT_KEY = '@aspectjs:memo/id';\nlet internalId = 0;\n\n/**\n * Options accepted by MemoAspect\n * @public\n */\n\nexport interface MemoAspectOptions {\n    /** use a namespace to avoid collision of data between eg: 2 different users */\n    namespace?: string | (() => string);\n    /** configure cache expiration in milliseconds or at a given specific date */\n    expiration?: Date | number | (() => Date | number);\n    /** get the identity of the class whose methods generates memoized data */\n    id?: string | number | ((ctxt: BeforeContext<any, any>) => string | number);\n    /** function that based on the execution context, generates the key to store cached data  */\n    createMemoKey?: (ctxt: BeforeContext<any, any>) => MemoKey | string;\n    /** marshallers to transform objects from / to storable structure */\n    marshallers?: MemoMarshaller[];\n    /** drivers that do the actual storage **/\n    drivers?: MemoDriver[];\n}\n\nconst DEFAULT_MEMO_ASPECT_OPTIONS: Required<MemoAspectOptions> = {\n    id: (ctxt: BeforeContext<any>) => {\n        const { id, _id, hashcode, _hashcode } = ctxt.instance;\n        const result = id ?? _id ?? hashcode ?? _hashcode;\n        if (isUndefined(result)) {\n            return getOrComputeMetadata(MEMO_ID_REFLECT_KEY, ctxt.instance, () => internalId++);\n        }\n        return result;\n    },\n    namespace: '',\n    createMemoKey: (ctxt: BeforeContext<any>) => {\n        return new MemoKey({\n            namespace: ctxt.data.namespace,\n            instanceId: ctxt.data.instanceId,\n            argsKey: hash(stringify(ctxt.args)),\n            targetKey: hash(`${ctxt.target.ref}`),\n        });\n    },\n    expiration: undefined,\n    marshallers: DEFAULT_MARSHALLERS,\n    drivers: [],\n};\n\n/**\n * Enable Memoization of a method's return value.\n * @public\n */\n@Aspect('@aspectjs/memo')\nexport class MemoAspect implements AspectType {\n    protected _options: MemoAspectOptions;\n    private readonly _drivers: Record<string, MemoDriver> = {};\n    /** maps memo keys with its unregister function for garbage collector timeouts */\n    private readonly _entriesGc: Map<string, number> = new Map();\n    private _marshallers: MarshallersRegistry;\n    private _pendingResults: Map<string, any> = new Map();\n    private _enabled: boolean;\n\n    constructor(params?: MemoAspectOptions) {\n        this._options = { ...DEFAULT_MEMO_ASPECT_OPTIONS, ...params };\n        this._marshallers = new MarshallersRegistry();\n        this.addMarshaller(...DEFAULT_MARSHALLERS, ...(this._options.marshallers ?? []));\n        this.addDriver(...(params?.drivers ?? []));\n    }\n\n    getDrivers(): Record<string, MemoDriver> {\n        return this._drivers;\n    }\n\n    public addDriver(...drivers: MemoDriver[]): this {\n        (drivers ?? []).forEach((d) => {\n            const existingDriver = this._drivers[d.NAME];\n            if (existingDriver === d) {\n                return;\n            }\n            if (existingDriver) {\n                throw new Error(\n                    `both ${d.constructor?.name} & ${existingDriver.constructor?.name} configured for name ${d.NAME}`,\n                );\n            }\n            this._drivers[d.NAME] = d;\n            if (this._enabled) {\n                this._initGc(d);\n            }\n        });\n        return this;\n    }\n\n    onEnable(): void {\n        this._enabled = true;\n        Object.values(this._drivers).forEach((d) => this._initGc(d));\n    }\n\n    addMarshaller(...marshallers: MemoMarshaller[]): void {\n        this._marshallers.addMarshaller(...marshallers);\n    }\n\n    removeMarshaller(...marshallers: MemoMarshaller[]): void {\n        this._marshallers.removeMarshaller(...marshallers);\n    }\n\n    /**\n     * Apply the memo pattern. That is, get the result from cache if any, or call the original method and store the result otherwise.\n     */\n    @Around(on.method.withAnnotations(Memo))\n    applyMemo(ctxt: AroundContext<any>, jp: JoinPoint): any {\n        const memoParams = ctxt.annotations.onSelf(Memo)[0].args[0] as MemoOptions;\n        ctxt.data.namespace = provider(memoParams?.namespace)() ?? provider(this._options?.namespace)();\n        ctxt.data.instanceId = `${provider(memoParams?.id)(ctxt) ?? provider(this._options?.id)(ctxt)}`;\n        const key = this._options.createMemoKey(ctxt) as MemoKey;\n\n        if (!key) {\n            throw new Error(`${this._options.createMemoKey.name} function did not return a valid MemoKey`);\n        }\n\n        const options = ctxt.annotations.onSelf(Memo)[0].args[0] as MemoOptions;\n        const expiration = this.getExpiration(ctxt, options);\n        const drivers = _selectCandidateDrivers(this._drivers, ctxt);\n\n        const proceedJoinpoint = () => {\n            // value not cached. Call the original method\n            const value = jp();\n            this._pendingResults.set(key.toString(), value);\n\n            // marshall the value into a frame\n            const marshallingContext = this._marshallers.marshal(value);\n\n            const driver = drivers\n                .filter((d) => d.accepts(marshallingContext))\n                .map((d) => [d, d.getPriority(marshallingContext)])\n                .sort((dp1: any, dp2: any) => dp2[1] - dp1[1])\n                .map((dp) => dp[0])[0] as MemoDriver;\n\n            if (!driver) {\n                throw new AspectError(\n                    ctxt,\n                    `Driver ${drivers[0].NAME} does not accept value of type ${\n                        getProto(value)?.constructor?.name ?? typeof value\n                    } returned by ${ctxt.target.label}`,\n                );\n            }\n\n            if (expiration) {\n                this._scheduleCleaner(driver, key, expiration);\n            }\n\n            marshallingContext.then((frame: MemoFrame<any>) => {\n                // promise resolution may not arrive in time in case the same method is called right after.\n                // store the result in a temporary variable in order to be available right away\n                const entry = {\n                    key,\n                    expiration,\n                    frame,\n                    signature: __createContextSignature(ctxt),\n                } as Mutable<MemoEntry>;\n\n                driver.write(entry).then(() => {\n                    const pendingResults = this._pendingResults.get(key.toString());\n\n                    if (pendingResults === value) {\n                        this._pendingResults.delete(key.toString());\n                    }\n                });\n            });\n            return value;\n        };\n        const pendingResults = this._pendingResults.get(key.toString());\n        if (pendingResults) {\n            return copy(pendingResults);\n        }\n        for (const d of drivers) {\n            try {\n                const entry = d.read(key);\n                if (entry) {\n                    if (entry.expiration && entry.expiration < new Date()) {\n                        // remove data if expired\n                        this._removeValue(d, key);\n                    } else if (entry.signature && entry.signature !== __createContextSignature(ctxt)) {\n                        // remove data if signature mismatch\n                        console.debug(`${ctxt.target.label} hash mismatch. Removing memoized data...`);\n                        this._removeValue(d, key);\n                    } else {\n                        return this._marshallers.unmarshal(entry.frame);\n                    }\n                }\n            } catch (e) {\n                // mute errors in ase of version mismatch, & just remove old version\n                if (e instanceof VersionConflictError || e instanceof MemoAspectError) {\n                    console.error(e);\n                    this._removeValue(d, key);\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // found no driver for this value. Call the real method\n        return proceedJoinpoint();\n    }\n\n    private _removeValue(driver: MemoDriver, key: MemoKey): void {\n        driver.remove(key);\n        // get gc timeout handle\n        const t = this._entriesGc.get(key.toString());\n        this._pendingResults.delete(key.toString());\n\n        if (t !== undefined) {\n            // this entry is not eligible for gc\n            this._entriesGc.delete(key.toString());\n\n            // remove gc timeout\n            clearTimeout(t as number);\n        }\n    }\n\n    private _scheduleCleaner(driver: MemoDriver, key: MemoKey, expiration: Date): void {\n        const ttl = expiration.getTime() - new Date().getTime();\n        if (ttl <= 0) {\n            this._removeValue(driver, key);\n        } else {\n            this._entriesGc.set(key.toString(), setTimeout(() => this._removeValue(driver, key), ttl) as any);\n        }\n    }\n\n    private _initGc(driver: MemoDriver): void {\n        driver.getKeys().then((keys) => {\n            keys.forEach((k) => {\n                Promise.resolve(driver.read(k)).then((memo) => {\n                    if (memo?.expiration) {\n                        this._scheduleCleaner(driver, k, memo.expiration);\n                    }\n                });\n            });\n        });\n    }\n\n    private getExpiration(ctxt: AroundContext<any>, options: MemoOptions): Date | undefined {\n        const exp = provider(options?.expiration)();\n        if (exp) {\n            if (exp instanceof Date) {\n                return exp;\n            } else if (typeof exp === 'number' && exp > 0) {\n                return new Date(new Date().getTime() + exp * 1000);\n            } else if (exp === 0) {\n                return;\n            }\n\n            throw new AspectError(ctxt, `expiration should be either a Date or a positive number. Got: ${exp}`);\n        }\n    }\n}\n\nfunction _selectCandidateDrivers(drivers: Record<string, MemoDriver>, ctxt: AroundContext<any, any>): MemoDriver[] {\n    const annotationOptions = (ctxt.annotations.onSelf(Memo)[0].args[0] ?? {}) as MemoOptions;\n    if (!annotationOptions.driver) {\n        // return all drivers\n        return Object.values(drivers);\n    } else {\n        if (isString(annotationOptions.driver)) {\n            const candidates = Object.values(drivers).filter((d) => d.NAME === annotationOptions.driver);\n            if (!candidates.length) {\n                throw new AspectError(\n                    ctxt,\n                    `No candidate driver available for driver name \"${annotationOptions.driver}\"`,\n                );\n            }\n\n            return candidates;\n        } else if (isFunction(annotationOptions.driver)) {\n            const candidates = Object.values(drivers).filter((d) => d.constructor === annotationOptions.driver);\n            if (!candidates.length) {\n                throw new AspectError(\n                    ctxt,\n                    `No candidate driver available for driver \"${annotationOptions.driver?.name}\"`,\n                );\n            }\n            return candidates;\n        } else {\n            throw new AspectError(\n                ctxt,\n                `driver option should be a string or a Driver constructor. Got: ${annotationOptions.driver}`,\n            );\n        }\n    }\n}\n\nfunction __createContextSignature(ctxt: AroundContext<unknown>) {\n    const s: string[] = [];\n    let proto = ctxt.target.proto as any;\n    let property = proto[ctxt.target.propertyKey];\n    while (proto !== Object.prototype && property) {\n        s.push(ctxt.target.proto[ctxt.target.propertyKey].toString());\n        proto = Reflect.getPrototypeOf(proto);\n        property = proto[ctxt.target.propertyKey];\n    }\n\n    return hash(s.join());\n}\n"],"names":[],"mappings":"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"}